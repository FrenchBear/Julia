# set_doc.jl
# Julia sets documentation, from doc Base > Collections and Data Structures > Set-Like Collections
# 
# 2024-04-21    PV      First version

# Set-Like Collections

# Base.AbstractSet
# Type AbstractSet{T}
# Supertype for set-like types whose elements are of type T. Set, BitSet and other types are subtypes of this.

# -------------------------------------------------
# Base.Set
# Type Set{T} <: AbstractSet{T}

# Sets are mutable containers that provide fast membership testing.
# Sets have efficient implementations of set operations such as in, union and intersect. Elements in a Set are unique,
# as determined by the elements' definition of isequal. The order of elements in a Set is an implementation detail and
# cannot be relied on.
# See also: AbstractSet, BitSet, Dict, push!, empty!, union!, in, isequal

s = Set("aaBca")                    # Set{Char} with 3 elements: 'a', 'c', 'B'
push!(s, 'b')                       # Set{Char} with 4 elements: 'a', 'b', 'B', 'c'
s = Set([NaN, 0.0, 1.0, 2.0])
-0.0 in s                           # false     # isequal(0.0, -0.0) is false
NaN in s                            # true      # isequal(NaN, NaN) is true

# -------------------------------------------------
# Base.BitSet
# Type BitSet([itr])

# Construct a sorted set of Ints generated by the given iterable object, or an empty set. Implemented as a bit string,
# and therefore designed for dense integer sets. If the set will be sparse (for example, holding a few very large
# integers), use Set instead.

# -------------------------------------------------
# Base.union
# Function union(s, itrs...)
# Function ∪(s, itrs...)

# Construct an object containing all distinct elements from all of the arguments.
# The first argument controls what kind of container is returned. If this is an array, it maintains the order in which
# elements first appear.
# Unicode ∪ can be typed by writing \cup then pressing tab in the Julia REPL, and in many editors. This is an infix
# operator, allowing s ∪ itr.
# See also unique, intersect, isdisjoint, vcat, Iterators.flatten.

union([1, 2], [3])                  # 3-element Vector{Int64}: 1, 2, 3
union([4 2 3 4 4], 1:3, 3.0)        # 4-element Vector{Float64}: 4.0, 2.0, 3.0, 1.0
(0, 0.0) ∪ (-0.0, NaN)              # 3-element Vector{Real}: 0, -0.0, NaN
union(Set([1, 2]), 2:3)             # Set{Int64} with 3 elements: 2, 3, 1

# -------------------------------------------------
# Base.union!
# Function union!(s::Union{AbstractSet,AbstractVector}, itrs...)

# Construct the union of passed in sets and overwrite s with the result. Maintain order with arrays.
# Warning: Behavior can be unexpected when any mutated argument shares memory with any other argument.

a = Set([3, 4, 5])
union!(a, 1:2:7)
a                                   # Set{Int64} with 5 elements: 5, 4, 7, 3, 1

# -------------------------------------------------
# Base.intersect
# Function intersect(s, itrs...)
# Function ∩(s, itrs...)

# Construct the set containing those elements which appear in all of the arguments.
# The first argument controls what kind of container is returned. If this is an array, it maintains the order in which
# elements first appear.
# Unicode ∩ can be typed by writing \cap then pressing tab in the Julia REPL, and in many editors. This is an infix
# operator, allowing s ∩ itr.
# See also setdiff, isdisjoint, issubset, issetequal.
# intersect returns a result with the eltype of the type-promoted eltypes of the two inputs
intersect([1, 2, 3], [3, 4, 5])                     # 1-element Vector{Int64}: 3
intersect([1, 4, 4, 5, 6], [6, 4, 6, 7, 8])         # 2-element Vector{Int64}: 4, 6
intersect(1:16, 7:99)                               # 7:16
(0, 0.0) ∩ (-0.0, 0)                                # 1-element Vector{Real}: 0
intersect(Set([1, 2]), BitSet([2, 3]), 1.0:10.0)    # Set{Float64} with 1 element: 2.0

# -------------------------------------------------
# Base.setdiff
# Function setdiff(s, itrs...)

# Construct the set of elements in s but not in any of the iterables in itrs. Maintain order with arrays.
# See also setdiff!, union and intersect.

setdiff([1,2,3], [3,4,5])           # 2-element Vector{Int64}: 1, 2

# -------------------------------------------------
# Base.setdiff!
# Function setdiff!(s, itrs...)

# Remove from set s (in-place) each element of each iterable from itrs. Maintain order with arrays.
# Warning: Behavior can be unexpected when any mutated argument shares memory with any other argument.

a = Set([1, 3, 4, 5])
setdiff!(a, 1:2:6);
a                                   # Set{Int64} with 1 element: 4

# -------------------------------------------------
# Base.symdiff
# Function symdiff(s, itrs...)

# Construct the symmetric difference of elements in the passed in sets. When s is not an AbstractSet, the order is maintained.
# See also symdiff!, setdiff, union and intersect.
# Symetric difference = elements in either sets but not in the intersection

symdiff([1,2,3], [3,4,5], [4,5,6])  # 3-element Vector{Int64}: 1, 2, 6
symdiff([1,2,1], [2, 1, 2])         # Int64[]

# -------------------------------------------------
# Base.symdiff!
# Function symdiff!(s::Union{AbstractSet,AbstractVector}, itrs...)

# Construct the symmetric difference of the passed in sets, and overwrite s with the result. When s is an array, the
# order is maintained. Note that in this case the multiplicity of elements matters.
# Warning: Behavior can be unexpected when any mutated argument shares memory with any other argument.

# -------------------------------------------------
# Base.intersect!
# Function intersect!(s::Union{AbstractSet,AbstractVector}, itrs...)

# Intersect all passed in sets and overwrite s with the result. Maintain order with arrays.
# Warning: Behavior can be unexpected when any mutated argument shares memory with any other argument.

# -------------------------------------------------
# Base.issubset
# Function issubset(a, b) -> Bool
# Function ⊆(a, b) -> Bool
# Function ⊇(b, a) -> Bool

# Determine whether every element of a is also in b, using in.
# See also ⊊, ⊈, ∩, ∪, contains.

issubset([1, 2], [1, 2, 3])         # true
[1, 2, 3] ⊆ [1, 2]                  # false
[1, 2, 3] ⊇ [1, 2]                  # true

# Base.:⊈, Base.⊉
# Function ⊈(a, b) -> Bool
# Function ⊉(b, a) -> Bool

# Negation of ⊆ and ⊇, i.e. checks that a is not a subset of b.
# See also issubset (⊆), ⊊.

(1, 2) ⊈ (2, 3)                     # true
(1, 2) ⊈ (1, 2, 3)                  # false

# Base.:⊊, Base.⊋
# Function ⊊(a, b) -> Bool
# Function ⊋(b, a) -> Bool

# Determines if a is a subset of, but not equal to, b.
# See also issubset (⊆), ⊈.

(1, 2) ⊊ (1, 2, 3)                  # true
(1, 2) ⊊ (1, 2)                     # false

# -------------------------------------------------
# Base.issetequal
# Function issetequal(a, b) -> Bool

# Determine whether a and b have the same elements. Equivalent to a ⊆ b && b ⊆ a but more efficient when possible.
# See also: isdisjoint, union.

issetequal([1, 2], [1, 2, 3])       # false
issetequal([1, 2], [2, 1])          # true

# -------------------------------------------------
# Base.isdisjoint
# Function isdisjoint(a, b) -> Bool

# Determine whether the collections a and b are disjoint. Equivalent to isempty(a ∩ b) but more efficient when possible.
# See also: intersect, isempty, issetequal.

isdisjoint([1, 2], [2, 3, 4])       # false
isdisjoint([3, 1], [2, 4])          # true



# Set Fully implemented by:
# BitSet
# Set

# Partially implemented by:
# Array
